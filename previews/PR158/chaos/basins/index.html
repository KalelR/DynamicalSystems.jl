<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Attractor Basins, Tipping Points · DynamicalSystems.jl</title><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.039/juliamono-regular.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.11/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script><link href="../../assets/logo.ico" rel="icon" type="image/x-icon"/><link href="https://fonts.googleapis.com/css?family=Montserrat|Source+Code+Pro&amp;display=swap" rel="stylesheet" type="text/css"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img src="../../assets/logo.png" alt="DynamicalSystems.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../../">DynamicalSystems.jl</a></span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">Introduction</a></li><li><a class="tocitem" href="../../contents/">Contents</a></li><li><input class="collapse-toggle" id="menuitem-3" type="checkbox"/><label class="tocitem" for="menuitem-3"><span class="docs-label">Dynamical systems</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../ds/general/">Dynamical System Definition</a></li><li><a class="tocitem" href="../../ds/predefined/">Predefined Dynamical Systems</a></li><li><a class="tocitem" href="../../embedding/dataset/">Numerical Data</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-4" type="checkbox"/><label class="tocitem" for="menuitem-4"><span class="docs-label">DelayEmbeddings</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../embedding/reconstruction/">Delay Coordinates Embedding</a></li><li><a class="tocitem" href="../../embedding/traditional/">Traditional Optimal Embedding</a></li><li><a class="tocitem" href="../../embedding/unified/">Unified Optimal Embedding</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-5" type="checkbox"/><label class="tocitem" for="menuitem-5"><span class="docs-label">Entropies</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../entropies/api/">Entropies &amp; Probabilities</a></li><li><a class="tocitem" href="../../entropies/estimators/">Probabilities Estimators</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-6" type="checkbox"/><label class="tocitem" for="menuitem-6"><span class="docs-label">RecurrenceAnalysis</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../rqa/rplots/">Recurrence Plots</a></li><li><a class="tocitem" href="../../rqa/quantification/">Recurrence Quantification Analysis</a></li><li><a class="tocitem" href="../../rqa/windowed/">Windowed RQA</a></li><li><a class="tocitem" href="../../rqa/networks/">Recurrence Networks</a></li></ul></li><li><a class="tocitem" href="../../advanced/">Advanced Documentation</a></li><li><a class="tocitem" href="../../contributors_guide/">Contributor Guide</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Attractor Basins, Tipping Points</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Attractor Basins, Tipping Points</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/JuliaDynamics/DynamicalSystems.jl/blob/master/docs/src/chaos/basins.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Attractor-Basins,-Tipping-Points"><a class="docs-heading-anchor" href="#Attractor-Basins,-Tipping-Points">Attractor Basins, Tipping Points</a><a id="Attractor-Basins,-Tipping-Points-1"></a><a class="docs-heading-anchor-permalink" href="#Attractor-Basins,-Tipping-Points" title="Permalink"></a></h1><p>In this page we list several functions related with basins of attraction and tipping points. In the example <a href="#D-basins-of-higher-dimensional-system">2D basins of higher dimensional system</a> we try to apply every single function listed below, so check this for an example application of everything listed here!</p><h2 id="Computing-basins-of-attraction"><a class="docs-heading-anchor" href="#Computing-basins-of-attraction">Computing basins of attraction</a><a id="Computing-basins-of-attraction-1"></a><a class="docs-heading-anchor-permalink" href="#Computing-basins-of-attraction" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="ChaosTools.basins_of_attraction" href="#ChaosTools.basins_of_attraction"><code>ChaosTools.basins_of_attraction</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">basins_of_attraction(grid::Tuple, ds::DynamicalSystem; kwargs...) -&gt; basins, attractors</code></pre><p>Compute an estimate of the basins of attraction of a dynamical system <code>ds</code> on a partitioning of the state space given by <code>grid</code>. The method has been inspired by the 2D grid approach developed by Nusse &amp; Yorke <sup class="footnote-reference"><a id="citeref-Yorke1997" href="#footnote-Yorke1997">[Yorke1997]</a></sup>. It works <em>without</em> knowledge of where attractors are; it identifies them automatically.</p><p>The dynamical system can be:</p><ul><li>An actual <code>DiscreteDynamicalSystem</code> or <code>ContinuousDynamicalSystem</code>.</li><li>A Poincaré map of <code>ContinuousDynamicalSystem</code>: <a href="../orbitdiagram/#ChaosTools.poincaremap"><code>poincaremap</code></a>.</li><li>A stroboscopic map, i.e. a periodically forced <code>ContinuousDynamicalSystem</code> (see examples for this particular application).</li></ul><p><code>grid</code> is a tuple of ranges defining the grid of initial conditions, for example <code>grid = (xg, yg)</code> where <code>xg = yg = range(-5, 5; length = 100)</code>. The grid is not necessarilly of the same dimension as the state space, attractors can be found in lower dimensional projections.</p><p>The output <code>basins</code> is an integer-valued array on the <code>grid</code>, with its entries labelling which basin of attraction the given grid point belongs to. The output <code>attractors</code> is a dictionary whose keys correspond to the attractor number and the values contains the points of the attractors found. Notice that for some attractors this list may be incomplete.</p><p>See also <a href="#ChaosTools.match_attractors!"><code>match_attractors!</code></a>, <a href="#ChaosTools.basin_fractions"><code>basin_fractions</code></a>, <a href="#ChaosTools.tipping_probabilities"><code>tipping_probabilities</code></a>.</p><p><strong>Keyword Arguments</strong></p><ul><li><code>Δt</code>: Approximate time step of the integrator, which is <code>1</code> for discrete systems. For continuous systems, an automatic value is calculated using <a href="#ChaosTools.automatic_Δt_basins"><code>automatic_Δt_basins</code></a>. See that function for more info.</li><li><code>T</code> : Period of the stroboscopic map, in case of a continuous dynamical system with periodic time forcing. This argument is incompatible with <code>Δt</code>.</li><li><code>idxs = 1:length(grid)</code>: This vector selects the variables of the system that will define the subspace the dynamics will be projected into.</li><li><code>complete_state = zeros(D-Dg)</code>: This argument allows setting the <em>remaining</em> variables of the dynamical system state on each initial condition <code>u</code>, with <code>Dg</code> the dimension of the grid. It can be either a vector of length <code>D-Dg</code>, or a function <code>f(y)</code> that returns a vector of length <code>D-Dg</code> given the <em>projected</em> initial condition on the grid <code>y</code>.</li><li><code>diffeq = NamedTuple()</code>: Keyword arguments propagated to <a href="../../advanced/#DynamicalSystemsBase.integrator"><code>integrator</code></a>. Only useful for continuous systems. It is <strong>strongly recommended</strong> to choose high accuracy solvers for this application, e.g. <code>diffeq = (alg = Vern9(), reltol = 1e-9, abstol = 1e-9)</code>.</li><li><code>mx_chk_att = 2</code>: A parameter that sets the maximum checks of consecutives hits of an attractor before deciding the basin of the initial condition.</li><li><code>mx_chk_hit_bas = 10</code> : Maximum check of consecutive visits of the same basin of attraction. This number can be increased for higher accuracy.</li><li><code>mx_chk_fnd_att = 100</code> : Maximum check of unnumbered cell before considering we have an attractor. This number can be increased for higher accuracy.</li><li><code>mx_chk_loc_att = 100</code> : Maximum check of consecutive cells marked as an attractor before considering that we have all the available pieces of the attractor.</li><li><code>mx_chk_lost</code> : Maximum check of iterations outside the defined grid before we consider the orbit lost outside. This number can be increased for higher accuracy. It defaults to <code>20</code> if no attractors are given (see discussion on refining basins), and to <code>1000</code> if attractors are given.</li><li><code>horizon_limit = 1e6</code> : If the norm of the integrator state reaches this limit we consider that the orbit diverges.</li><li><code>show_progress = true</code> : By default a progress bar is shown using ProgressMeter.jl.</li><li><code>attractors, ε</code>: See discussion on refining basins below.</li></ul><p><strong>Description</strong></p><p><code>basins</code> has the following organization:</p><ul><li>The basins are coded in sequential order from 1 up to the number of attractors.</li><li>If the trajectory diverges or converges to an attractor outside the defined grid it is numbered <code>-1</code></li></ul><p><code>attractors</code> has the following organization:</p><ul><li>The keys of the dictionary correspond to the number of the attractor.</li><li>The value associated to a key is a <a href="../../embedding/dataset/#DelayEmbeddings.Dataset"><code>Dataset</code></a> with the <em>guessed</em> location of the attractor on the state space.</li></ul><p>The method starts by picking the first available initial condition on the grid not yet numbered. The dynamical system is then iterated until one of the following conditions happens:</p><ol><li>The trajectory hits a known attractor already numbered <code>mx_chk_att</code> consecutive times: the initial condition is numbered with the corresponding number.</li><li>The trajectory spends <code>mx_chk_lost</code> steps outside the defiend grid: the initial condition is set to -1.</li><li>The trajectory hits a known basin <code>mx_chk_hit_bas</code> times in a row: the initial condition belongs to that basin and is numbered accordingly.</li><li>The trajectory hits <code>mx_chk_fnd_att</code> times in a row an unnumbered cell: it is considered an attractor and is labelled with a new number.</li></ol><p>Regarding performace, this method is at worst as fast as tracking the attractors. In most cases there is a signicative improvement in speed.</p><p>Notice that in the case we have to project the dynamics on a lower dimensional space, there are edge cases where the system may have two attractors that are close on the projected space but are far apart in another dimension. They could be collapsed or confused into the same attractor. This is a drawback of this method.</p><p><strong>Refining basins of attraction</strong></p><p>Sometimes one would like to be able to refine the found basins of attraction by recomputing <code>basins_of_attraction</code> on a smaller, and more fine-grained, <code>grid</code>. If however this new <code>grid</code> does not contain the attractors, <code>basins_of_attraction</code> would (by default) attribute the value <code>-1</code> to all grid points. For these cases, an extra search clause can be provided by setting the keywords <code>attractors, ε</code>. The <code>attractors</code> is a dictionary mapping attractor IDs to <code>Dataset</code>s (i.e., the same as the return value of <code>basins_of_attraction</code>). The algorithm checks at each step whether the system state is <code>ε</code>-close (Euclidean norm) to any of the given attractors, and if so it attributes the stating grid point to the basin of the close attractor. By default <code>ε</code> is equal to the mean grid spacing.</p><p>A word of advice while using this method: in order to work properly, <code>ε</code> should be about the size of a grid cell that has been used to compute the given <code>attractors</code>. It is recomended to keep the same step size (i.e., use the same integrator) since it may have an influence in some cases. This algorithm is usually slower than the method with the attractors on the grid.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="ChaosTools.automatic_Δt_basins" href="#ChaosTools.automatic_Δt_basins"><code>ChaosTools.automatic_Δt_basins</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">automatic_Δt_basins(ds, grid; kwargs...) → Δt</code></pre><p>Calculate an optimal <code>Δt</code> value for <a href="#ChaosTools.basins_of_attraction"><code>basins_of_attraction</code></a>. This is done by evaluating the dynamic rule <code>f</code> (vector field) at <code>N</code> randomly chosen points of the grid. The average <code>f</code> is then compared with the diagonal length of a grid cell and their ratio provides <code>Δt</code>.</p><p>Keywords <code>idxs, complete_state, diffeq</code> are exactly as in <a href="#ChaosTools.basins_of_attraction"><code>basins_of_attraction</code></a>, and the keyword <code>N</code> is <code>5000</code> by default.</p><p>Notice that <code>Δt</code> should not be too small which happens typically if the grid resolution is high. It is okay for <a href="#ChaosTools.basins_of_attraction"><code>basins_of_attraction</code></a> if the trajectory skips a few cells. But if <code>Δt</code> is too small the default values for all other keywords such  as <code>mx_chk_hit_bas</code> need to be increased drastically.</p><p>Also, <code>Δt</code> that is smaller than the internal step size of the integrator will cause a performance drop.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="ChaosTools.match_attractors!" href="#ChaosTools.match_attractors!"><code>ChaosTools.match_attractors!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">match_attractors!(b₋, a₋, b₊, a₊, [, method = :distance])</code></pre><p>Attempt to match the attractors in basins/attractors <code>b₊, a₊</code> with those at <code>b₋, a₋</code>. <code>b</code> is an array whose values encode the attractor ID, while <code>a</code> is a dictionary mapping IDs to <code>Dataset</code>s containing the attractors (e.g. output of <a href="#ChaosTools.basins_of_attraction"><code>basins_of_attraction</code></a>). Typically the +,- mean after and before some change of parameter for a system.</p><p>In <a href="#ChaosTools.basins_of_attraction"><code>basins_of_attraction</code></a> different attractors get assigned different IDs, however which attractor gets which ID is somewhat arbitrary, and computing the basins of the same system for slightly different parameters could label the &quot;same&quot; attractors (at the different parameters) with different IDs. <code>match_attractors!</code> tries to &quot;match&quot; them by modifying the attractor IDs.</p><p>The modification of IDs is always done on the <code>b, a</code> that have less attractors.</p><p><code>method</code> decides the matching process:</p><ul><li><code>method = :overlap</code> matches attractors whose basins before and after have the most overlap (in pixels).</li><li><code>method = :distance</code> matches attractors whose state space distance the smallest.</li></ul></div></section></article><h2 id="Final-state-sensitivity-/-fractal-boundaries"><a class="docs-heading-anchor" href="#Final-state-sensitivity-/-fractal-boundaries">Final state sensitivity / fractal boundaries</a><a id="Final-state-sensitivity-/-fractal-boundaries-1"></a><a class="docs-heading-anchor-permalink" href="#Final-state-sensitivity-/-fractal-boundaries" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="ChaosTools.basins_fractal_dimension" href="#ChaosTools.basins_fractal_dimension"><code>ChaosTools.basins_fractal_dimension</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">basins_fractal_dimension(basins; kwargs...) -&gt; V_ε, N_ε ,d</code></pre><p>Estimate the <a href="../fractaldim/#Fractal-Dimension">Fractal Dimension</a> <code>d</code> of the boundary between basins of attraction using the box-counting algorithm.</p><p>The output <code>N_ε</code> is a vector with the number of the balls of radius <code>ε</code> (in pixels) that contain at least two initial conditions that lead to different attractors. <code>V_ε</code> is a vector with the corresponding size of the balls. The ouput <code>d</code> is the estimation of the box-counting dimension of the boundary by fitting a line in the <code>log.(N_ε)</code> vs <code>log.(1/V_ε)</code> curve. However it is recommended to analyze the curve directly for more accuracy.</p><p><strong>Keyword arguments</strong></p><ul><li><code>range_ε = 2:maximum(size(basins))÷20</code> is the range of sizes of the ball to test (in pixels).</li></ul><p><strong>Description</strong></p><p>It is the implementation of the popular algorithm of the estimation of the box-counting dimension. The algorithm search for a covering the boundary with <code>N_ε</code> boxes of size <code>ε</code> in pixels.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="ChaosTools.basin_entropy" href="#ChaosTools.basin_entropy"><code>ChaosTools.basin_entropy</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">basin_entropy(basins, ε = 20) -&gt; Sb, Sbb</code></pre><p>This algorithm computes the basin entropy <code>Sb</code> of the basins of attraction. First, the input <code>basins</code> is divided regularly into n-dimensional boxes of side <code>ε</code> (along all dimensions). Then <code>Sb</code> is simply the average of the Gibbs entropy computed over these boxes. The function returns the basin entropy <code>Sb</code> as well as the boundary basin entropy <code>Sbb</code>. The later is the average of the entropy only for boxes that contains at least two different basins, that is, for the boxes on the boundary.</p><p>The basin entropy is a measure of the uncertainty on the initial conditions of the basins. It is maximum at the value <code>log(n_att)</code> being <code>n_att</code> the number of attractors. In this case the boundary is intermingled: for a given initial condition we can find another initial condition that lead to another basin arbitriraly close. It provides also a simple criterion for fractality: if the boundary basin entropy <code>Sbb</code> is above <code>log(2)</code> then we have a fractal boundary. It doesn&#39;t mean that basins with values below cannot have a fractal boundary, for a more precise test see <a href="#ChaosTools.basins_fractal_test"><code>basins_fractal_test</code></a>. An important feature of the basin entropy is that it allows comparisons between different basins using the same box size <code>ε</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="ChaosTools.basins_fractal_test" href="#ChaosTools.basins_fractal_test"><code>ChaosTools.basins_fractal_test</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">basins_fractal_test(basins; ε = 20, Ntotal = 1000) -&gt; test_res, Sbb</code></pre><p>This is an automated test to decide if the boundary of the basins has fractal structures. The bottom line is to look at the basins with a magnifier of size <code>ε</code> at random in <code>basins</code>. If what we see in the magnifier looks like a smooth boundary (in average) we decide that the boundary is smooth. If it is not smooth we can say that at the scale <code>ε</code> we have structures, i.e., it is fractal.</p><p>In practice the algorithm computes the boundary basin entropy <code>Sbb</code> <a href="#ChaosTools.basin_entropy"><code>basin_entropy</code></a> for <code>Ntotal</code> random balls of radius <code>ε</code>. If the computed value is equal to theoretical value of a smooth boundary (taking into account statistical errors and biases) then we decide that we have a smooth boundary. Notice that the response <code>test_res</code> may depend on the chosen ball radius <code>ε</code>. For larger size, we may observe structures for smooth boundary and we obtain a <em>different</em> answer.</p><p>The output <code>test_res</code> is a symbol describing the nature of the basin and the output <code>Sbb</code> is the estimated value of the boundary basin entropy with the sampling method.</p><p><sup class="footnote-reference"><a id="citeref-Puy2021" href="#footnote-Puy2021">[Puy2021]</a></sup> Andreu Puy, Alvar Daza, Alexandre Wagemakers, Miguel A. F. Sanjuán. A test for fractal boundaries based on the basin entropy. Commun Nonlinear Sci Numer Simulat, 95, 105588, 2021.</p><p><strong>Keyword arguments</strong></p><ul><li><code>ε = 20</code>: size of the ball for the test of basin. The result of the test may change with the size.</li><li><code>Ntotal = 1000</code>: number of balls to test in the boundary for the computation of <code>Sbb</code></li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="ChaosTools.uncertainty_exponent" href="#ChaosTools.uncertainty_exponent"><code>ChaosTools.uncertainty_exponent</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">uncertainty_exponent(basins; kwargs...) -&gt; ε, N_ε ,α</code></pre><p>Estimate the uncertainty exponent<sup class="footnote-reference"><a id="citeref-Grebogi1983" href="#footnote-Grebogi1983">[Grebogi1983]</a></sup> of the basins of attraction. This exponent is related to the final state sensitivity of the trajectories in the phase space. An exponent close to <code>1</code> means basins with smooth boundaries whereas an exponent close to <code>0</code> represent complety fractalized basins, also called riddled basins.</p><p>The output <code>N_ε</code> is a vector with the number of the balls of radius <code>ε</code> (in pixels) that contain at least two initial conditions that lead to different attractors. The ouput <code>α</code> is the estimation of the uncertainty exponent using the box-counting dimension of the boundary by fitting a line in the <code>log.(N_ε)</code> vs <code>log.(1/ε)</code> curve. However it is recommended to analyze the curve directly for more accuracy.</p><p><strong>Keyword arguments</strong></p><ul><li><code>range_ε = 2:maximum(size(basins))÷20</code> is the range of sizes of the ball to test (in pixels).</li></ul><p><strong>Description</strong></p><p>A phase space with a fractal boundary may cause a uncertainty on the final state of the dynamical system for a given initial condition. A measure of this final state sensitivity is the uncertainty exponent. The algorithm probes the basin of attraction with balls of size <code>ε</code> at random. If there are a least two initial conditions that lead to different attractors, a ball is tagged &quot;uncertain&quot;. <code>f_ε</code> is the fraction of &quot;uncertain balls&quot; to the total number of tries in the basin. In analogy to the fractal dimension, there is a scaling law between, <code>f_ε ~ ε^α</code>. The number that characterizes this scaling is called the uncertainty exponent <code>α</code>.</p><p>Notice that the uncertainty exponent and the box counting dimension of the boundary are related. We have <code>Δ₀ = D - α</code> where <code>Δ₀</code> is the box counting dimension computed with <a href="#ChaosTools.basins_fractal_dimension"><code>basins_fractal_dimension</code></a> and <code>D</code> is the dimension of the phase space. The algorithm first estimates the box counting dimension of the boundary and returns the uncertainty exponent.</p></div></section></article><h2 id="Tipping-points"><a class="docs-heading-anchor" href="#Tipping-points">Tipping points</a><a id="Tipping-points-1"></a><a class="docs-heading-anchor-permalink" href="#Tipping-points" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="ChaosTools.basin_fractions" href="#ChaosTools.basin_fractions"><code>ChaosTools.basin_fractions</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">basin_fractions(basins::Array) → fs::Dict</code></pre><p>Calculate the fraction of the basins of attraction encoded in <code>basins</code>. The elements of <code>basins</code> are integers, enumerating the attractor that the entry of <code>basins</code> converges to. Return a dictionary that maps attractor IDs to their relative fractions.</p><p>In<sup class="footnote-reference"><a id="citeref-Menck2013" href="#footnote-Menck2013">[Menck2013]</a></sup> the authors use these fractions to quantify the stability of a basin of attraction, and specifically how it changes when a parameter is changed.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="ChaosTools.tipping_probabilities" href="#ChaosTools.tipping_probabilities"><code>ChaosTools.tipping_probabilities</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">tipping_probabilities(basins_before, basins_after) → P</code></pre><p>Return the tipping probabilities of the computed basins before and after a change in the system parameters (or time forcing), according to the definition of<sup class="footnote-reference"><a id="citeref-Kaszás2019" href="#footnote-Kaszás2019">[Kaszás2019]</a></sup>.</p><p>The input <code>basins</code> are integer-valued arrays, where the integers enumerate the attractor, e.g. the output of <a href="#ChaosTools.basins_of_attraction"><code>basins_of_attraction</code></a>.</p><p><strong>Description</strong></p><p>Let <span>$\mathcal{B}_i(p)$</span> denote the basin of attraction of attractor <span>$A_i$</span> at parameter(s) <span>$p$</span>. Kaszás et al<sup class="footnote-reference"><a id="citeref-Kaszás2019" href="#footnote-Kaszás2019">[Kaszás2019]</a></sup> define the tipping probability from <span>$A_i$</span> to <span>$A_j$</span>, given a parameter change in the system of <span>$p_- \to p_+$</span>, as</p><p class="math-container">\[P(A_i \to A_j | p_- \to p_+) =
\frac{|\mathcal{B}_j(p_+) \cap \mathcal{B}_i(p_-)|}{|\mathcal{B}_i(p_-)|}\]</p><p>where <span>$|\cdot|$</span> is simply the volume of the enclosed set. The value of <span>$P(A_i \to A_j | p_- \to p_+)$</span> is <code>P[i, j]</code>. The equation describes something quite simple: what is the overlap of the basin of attraction of <span>$A_i$</span> at <span>$p_-$</span> with that of the attractor <span>$A_j$</span> at <span>$p_+$</span>. If <code>basins_before, basins_after</code> contain values of <code>-1</code>, corresponding to trajectories that diverge, this is considered as the last attractor of the system in <code>P</code>.</p></div></section></article><h2 id="Discrete-system-example"><a class="docs-heading-anchor" href="#Discrete-system-example">Discrete system example</a><a id="Discrete-system-example-1"></a><a class="docs-heading-anchor-permalink" href="#Discrete-system-example" title="Permalink"></a></h2><pre><code class="language- hljs">using DynamicalSystems, PyPlot
function newton_map(dz, z, p, n)
    z1 = z[1] + im*z[2]
    dz1 = newton_f(z1, p[1])/newton_df(z1, p[1])
    z1 = z1 - dz1
    dz[1]=real(z1)
    dz[2]=imag(z1)
    return
end
newton_f(x, p) = x^p - 1
newton_df(x, p)= p*x^(p-1)

# dummy Jacobian function due to https://github.com/JuliaDiff/ForwardDiff.jl/issues/520
function newton_map_J(J,z0, p, n) end

ds = DiscreteDynamicalSystem(newton_map, [0.1, 0.2], [3.0], newton_map_J)
xg = yg = range(-1.5,1.5,length=400)
basins, attractors = basins_of_attraction((xg, yg), ds; show_progress = false)
basins</code></pre><pre><code class="language- hljs">attractors</code></pre><p>Now let&#39;s plot this as a heatmap</p><pre><code class="language- hljs"># Set up some code for plotting attractors
function scatter_attractors(attractors)
    for k ∈ keys(attractors)
        x, y = columns(attractors[k])
        scatter(x, y; color = &quot;C$(k-1)&quot;, edgecolor = &quot;white&quot;)
    end
end
LC =  matplotlib.colors.ListedColormap
cmap = LC([matplotlib.colors.to_rgb(&quot;C$k&quot;) for k in 0:3])
vmin = 1; vmax = 4

fig = figure()
pcolormesh(xg, yg, basins&#39;; cmap, vmin, vmax)
scatter_attractors(attractors)
fig.tight_layout(pad=0.3); fig</code></pre><h2 id="Stroboscopic-map-example"><a class="docs-heading-anchor" href="#Stroboscopic-map-example">Stroboscopic map example</a><a id="Stroboscopic-map-example-1"></a><a class="docs-heading-anchor-permalink" href="#Stroboscopic-map-example" title="Permalink"></a></h2><p>This example targets periodically driven 2D continuous dynamical systems, like the Duffing oscillator:</p><pre><code class="language- hljs">using DynamicalSystems, PyPlot
ω=1.0; f = 0.2
ds = Systems.duffing([0.1, 0.25]; ω, f, d = 0.15, β = -1)</code></pre><p>For stroboscopic maps, we strongly recommend using a higher precision integrator from OrdinaryDiffEq.jl.</p><pre><code class="language- hljs">using OrdinaryDiffEq
diffeq = (alg = Tsit5(), reltol = 1e-9)
xg = yg = range(-2.2,2.2,length=200)
basins, attractors = basins_of_attraction((xg, yg), ds; T=2π/ω, diffeq, show_progress = false)
basins</code></pre><p>And visualize the result as a heatmap, scattering the found attractors via scatter.</p><pre><code class="language- hljs">fig = figure()
pcolormesh(xg, yg, basins&#39;; cmap, vmin, vmax)
scatter_attractors(attractors)
fig.tight_layout(pad=0.3); fig</code></pre><h2 id="D-basins-of-higher-dimensional-system"><a class="docs-heading-anchor" href="#D-basins-of-higher-dimensional-system">2D basins of higher dimensional system</a><a id="D-basins-of-higher-dimensional-system-1"></a><a class="docs-heading-anchor-permalink" href="#D-basins-of-higher-dimensional-system" title="Permalink"></a></h2><p>In this section we will calculate the basins of attraction of the four-dimensional magnetic pendulum. We know that the attractors of this system are all individual fixed points on the (x, y) plane so we will only compute the basins there. See the <a href="#D-basins">3D basins</a> section for something even more complex.</p><h3 id="Computing-the-basins"><a class="docs-heading-anchor" href="#Computing-the-basins">Computing the basins</a><a id="Computing-the-basins-1"></a><a class="docs-heading-anchor-permalink" href="#Computing-the-basins" title="Permalink"></a></h3><pre><code class="language-julia hljs">ds = Systems.magnetic_pendulum(d=0.2, α=0.2, ω=0.8, N=3)
xg = yg = range(-4, 4, length=150)
@time basins, attractors = basins_of_attraction((xg, yg), ds; diffeq = (reltol = 1e-9,), show_progress = false)
attractors</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Dict{Int16, Dataset{4, Float64}} with 3 entries:
  2 =&gt; 4-dimensional Dataset{Float64} with 1 points
  3 =&gt; 4-dimensional Dataset{Float64} with 1 points
  1 =&gt; 4-dimensional Dataset{Float64} with 2 points</code></pre><p>Alright, so far so good, we found 3 attractors (the 3 magnets). Let&#39;s visualize this beauty now</p><pre><code class="language- hljs">fig = figure()
pcolormesh(xg, yg, basins&#39;; cmap, vmin, vmax)
scatter_attractors(attractors)
fig.tight_layout(pad=0.3); fig</code></pre><h3 id="Computing-the-uncertainty-exponent"><a class="docs-heading-anchor" href="#Computing-the-uncertainty-exponent">Computing the uncertainty exponent</a><a id="Computing-the-uncertainty-exponent-1"></a><a class="docs-heading-anchor-permalink" href="#Computing-the-uncertainty-exponent" title="Permalink"></a></h3><p>Let&#39;s now calculate the <a href="#ChaosTools.uncertainty_exponent"><code>uncertainty_exponent</code></a> for this system as well. The calculation is straightforward:</p><pre><code class="language- hljs">ε, f_ε, α = uncertainty_exponent(basins)
fig = figure()
plot(log.(ε), log.(f_ε))
plot(log.(ε), log.(ε) .* α; label = &quot;α = $(round(α; digits=3))&quot;)
legend()
fig.tight_layout(pad=0.3); fig</code></pre><p>The actual uncertainty exponent is the slope of the curve.</p><h3 id="Computing-the-tipping-probabilities"><a class="docs-heading-anchor" href="#Computing-the-tipping-probabilities">Computing the tipping probabilities</a><a id="Computing-the-tipping-probabilities-1"></a><a class="docs-heading-anchor-permalink" href="#Computing-the-tipping-probabilities" title="Permalink"></a></h3><p>We will compute the tipping probabilities using the magnetic pendulum&#39;s example as the &quot;before&quot; state. For the &quot;after&quot; state we will change the <code>γ</code> parameter of the third magnet to be so small, it&#39;s basin of attraction will virtually disappear.</p><pre><code class="language- hljs">ds = Systems.magnetic_pendulum(d=0.2, α=0.2, ω=0.8, N=3, γs = [1.0, 1.0, 0.1])
basins_after, attractors_after = basins_of_attraction(
    (xg, yg), ds; diffeq = (reltol = 1e-9,), show_progress = false
)
match_attractors!(basins, attractors, basins_after, attractors_after)
fig = figure()
pcolormesh(xg, yg, basins_after&#39;; vmin, vmax, cmap)
scatter_attractors(attractors_after)
fig.tight_layout(pad=0.3); fig</code></pre><pre><code class="language-julia hljs">P = tipping_probabilities(basins, basins_after)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">3×2 Matrix{Float64}:
 0.506439  0.493561
 0.456852  0.543148
 0.562945  0.437055</code></pre><p>As you can see <code>P</code> has size 3×2, as after the change only 2 attractors have been identified in the system (3 still exist but our state space discretization isn&#39;t accurate enough to find the 3rd because it has such a small basin). Also, the first row of <code>P</code> is 50% probability to each other magnet, as it should be due to the system&#39;s symmetry.</p><h2 id="D-basins"><a class="docs-heading-anchor" href="#D-basins">3D basins</a><a id="D-basins-1"></a><a class="docs-heading-anchor-permalink" href="#D-basins" title="Permalink"></a></h2><p>To showcase the true power of <a href="#ChaosTools.basins_of_attraction"><code>basins_of_attraction</code></a> we need to use a system whose attractors span higher-dimensional space. An example is </p><pre><code class="language-julia hljs">ds = Systems.thomas_cyclical(b = 0.1665)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">3-dimensional continuous dynamical system
 state:       [1.0, 0.0, 0.0]
 rule f:      thomas_rule
 in-place?    false
 jacobian:    thomas_jacob
 parameters:  [0.1665]</code></pre><p>which, for this parameter, contains 5 coexisting attractors. 3 of them are entangled periodic orbits that span across all three dimensions, and the remaining 2 are fixed points.</p><p>To compute the basins we define a three-dimensional grid and call on it <a href="#ChaosTools.basins_of_attraction"><code>basins_of_attraction</code></a>.</p><pre><code class="language-julia hljs"># This computation takes about an hour
xg = yg = zg = range(-6.0, 6.0; length = 251)
basins, attractors = basins_of_attraction((xg, yg, zg), ds)
attractors</code></pre><pre><code class="nohighlight hljs">Dict{Int16, Dataset{3, Float64}} with 5 entries:
  5 =&gt; 3-dimensional Dataset{Float64} with 1 points
  4 =&gt; 3-dimensional Dataset{Float64} with 379 points
  6 =&gt; 3-dimensional Dataset{Float64} with 1 points
  2 =&gt; 3-dimensional Dataset{Float64} with 538 points
  3 =&gt; 3-dimensional Dataset{Float64} with 537 points
  1 =&gt; 3-dimensional Dataset{Float64} with 1 points</code></pre><p>The basins of attraction are very complicated. We can try to visualize them by animating the 2D slices at each z value, to obtain:</p><video width="75%" height="auto" controls autoplay loop>
<source src="https://raw.githubusercontent.com/JuliaDynamics/JuliaDynamics/master/videos/chaos/cyclical_basins.mp4?raw=true" type="video/mp4">
</video><p>Then, we visualize the attractors to obtain:</p><video width="75%" height="auto" controls autoplay loop>
<source src="https://raw.githubusercontent.com/JuliaDynamics/JuliaDynamics/master/videos/chaos/cyclical_attractors.mp4?raw=true" type="video/mp4">
</video><p>In the animation above, the scattered points are the attractor values the function <a href="#ChaosTools.basins_of_attraction"><code>basins_of_attraction</code></a> found by itself. Of course, for the periodic orbits these points are incomplete. Once the function&#39;s logic understood we are on an attractor, it stops computing. However, we also simulated lines, by evolving initial conditions colored appropriately with the basins output.</p><p>The animation was produced with the code:</p><pre><code class="language-julia hljs">using GLMakie
fig = Figure()
display(fig)
ax = fig[1,1] = Axis3(fig; title = &quot;found attractors&quot;)
cmap = cgrad(:dense, 6; categorical = true)

for i in keys(attractors)
    tr = attractors[i]
    markersize = length(attractors[i]) &gt; 10 ? 2000 : 6000
    marker = length(attractors[i]) &gt; 10 ? :circle : :rect
    scatter!(ax, columns(tr)...; markersize, marker, transparency = true, color = cmap[i])
    j = findfirst(isequal(i), bsn)
    x = xg[j[1]]
    y = yg[j[2]]
    z = zg[j[3]]
    tr = trajectory(ds, 100, SVector(x,y,z); Ttr = 100)
    lines!(ax, columns(tr)...; linewidth = 1.0, color = cmap[i])
end

a = range(0, 2π; length = 200) .+ π/4

record(fig, &quot;cyclical_attractors.mp4&quot;, 1:length(a)) do i
    ax.azimuth = a[i]
end</code></pre><h2 id="Poincaré-map-example"><a class="docs-heading-anchor" href="#Poincaré-map-example">Poincaré map example</a><a id="Poincaré-map-example-1"></a><a class="docs-heading-anchor-permalink" href="#Poincaré-map-example" title="Permalink"></a></h2><p>In the previous example we saw that this system has periodic attractors. In the Poincaré map these periodic attractors become points. We can use the functionality of <a href="#ChaosTools.basins_of_attraction"><code>basins_of_attraction</code></a> and <a href="../orbitdiagram/#ChaosTools.poincaremap"><code>poincaremap</code></a> to find basins of attraction on the Poincaré surface of section.</p><pre><code class="language-julia hljs">ds = Systems.thomas_cyclical(b = 0.1665)
xg = yg = range(-6.0, 6.0; length = 100)
pmap = poincaremap(ds, (3, 0.0), 1e6;
    rootkw = (xrtol = 1e-8, atol = 1e-8), reltol=1e-9
)
basins, attractors = basins_of_attraction((xg,yg), pmap; show_progress = false)
attractors</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Dict{Int16, Dataset{3, Float64}} with 3 entries:
  2 =&gt; 3-dimensional Dataset{Float64} with 1 points
  3 =&gt; 3-dimensional Dataset{Float64} with 3 points
  1 =&gt; 3-dimensional Dataset{Float64} with 1 points</code></pre><pre><code class="language-julia hljs">attractors[1]</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">3-dimensional Dataset{Float64} with 1 points
 1.83899  -4.15575  2.05366e-11</code></pre><p>Looks good so far, but let&#39;s plot it as well:</p><pre><code class="language- hljs">fig = figure()
pcolormesh(xg, yg, basins&#39;; cmap, vmin, vmax)
scatter_attractors(attractors)
fig.tight_layout(pad=0.3); fig</code></pre><p>This aligns perfectly with the video we produced above.</p><section class="footnotes is-size-7"><ul><li class="footnote" id="footnote-Yorke1997"><a class="tag is-link" href="#citeref-Yorke1997">Yorke1997</a>H. E. Nusse and J. A. Yorke, Dynamics: numerical explorations Ch. 7, Springer, New York, 1997</li><li class="footnote" id="footnote-Daza2016"><a class="tag is-link" href="#citeref-Daza2016">Daza2016</a>A. Daza, A. Wagemakers, B. Georgeot, D. Guéry-Odelin and M. A. F. Sanjuán, Basin entropy: a new tool to analyze uncertainty in dynamical systems, Sci. Rep., 6, 31416, 2016.</li><li class="footnote" id="footnote-Grebogi1983"><a class="tag is-link" href="#citeref-Grebogi1983">Grebogi1983</a>C. Grebogi, S. W. McDonald, E. Ott and J. A. Yorke, Final state sensitivity: An obstruction to predictability, Physics Letters A, 99, 9, 1983</li><li class="footnote" id="footnote-Menck2013"><a class="tag is-link" href="#citeref-Menck2013">Menck2013</a>Menck, Heitzig, Marwan &amp; Kurths. How basin stability complements the linear stability paradigm. <a href="https://doi.org/10.1038/nphys2516">Nature Physics, 9(2), 89–92</a></li><li class="footnote" id="footnote-Kaszás2019"><a class="tag is-link" href="#citeref-Kaszás2019">Kaszás2019</a>Kaszás, Feudel &amp; Tél. Tipping phenomena in typical dynamical systems subjected to parameter drift. <a href="https://doi.org/10.1038/s41598-019-44863-3">Scientific Reports, 9(1)</a></li></ul></section></article><nav class="docs-footer"><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.10 on <span class="colophon-date" title="Saturday 4 December 2021 20:51">Saturday 4 December 2021</span>. Using Julia version 1.7.0.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
