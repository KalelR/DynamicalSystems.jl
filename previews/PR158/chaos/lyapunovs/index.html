<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Lyapunov Exponents · DynamicalSystems.jl</title><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.039/juliamono-regular.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.11/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script><link href="../../assets/logo.ico" rel="icon" type="image/x-icon"/><link href="https://fonts.googleapis.com/css?family=Montserrat|Source+Code+Pro&amp;display=swap" rel="stylesheet" type="text/css"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img src="../../assets/logo.png" alt="DynamicalSystems.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../../">DynamicalSystems.jl</a></span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">Introduction</a></li><li><a class="tocitem" href="../../contents/">Contents</a></li><li><input class="collapse-toggle" id="menuitem-3" type="checkbox"/><label class="tocitem" for="menuitem-3"><span class="docs-label">Dynamical systems</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../ds/general/">Dynamical System Definition</a></li><li><a class="tocitem" href="../../ds/predefined/">Predefined Dynamical Systems</a></li><li><a class="tocitem" href="../../embedding/dataset/">Numerical Data</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-4" type="checkbox"/><label class="tocitem" for="menuitem-4"><span class="docs-label">DelayEmbeddings</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../embedding/reconstruction/">Delay Coordinates Embedding</a></li><li><a class="tocitem" href="../../embedding/traditional/">Traditional Optimal Embedding</a></li><li><a class="tocitem" href="../../embedding/unified/">Unified Optimal Embedding</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-5" type="checkbox"/><label class="tocitem" for="menuitem-5"><span class="docs-label">Entropies</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../entropies/api/">Entropies &amp; Probabilities</a></li><li><a class="tocitem" href="../../entropies/estimators/">Probabilities Estimators</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-6" type="checkbox"/><label class="tocitem" for="menuitem-6"><span class="docs-label">RecurrenceAnalysis</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../rqa/rplots/">Recurrence Plots</a></li><li><a class="tocitem" href="../../rqa/quantification/">Recurrence Quantification Analysis</a></li><li><a class="tocitem" href="../../rqa/windowed/">Windowed RQA</a></li><li><a class="tocitem" href="../../rqa/networks/">Recurrence Networks</a></li></ul></li><li><a class="tocitem" href="../../advanced/">Advanced Documentation</a></li><li><a class="tocitem" href="../../contributors_guide/">Contributor Guide</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Lyapunov Exponents</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Lyapunov Exponents</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/JuliaDynamics/DynamicalSystems.jl/blob/master/docs/src/chaos/lyapunovs.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Lyapunov-Exponents"><a class="docs-heading-anchor" href="#Lyapunov-Exponents">Lyapunov Exponents</a><a id="Lyapunov-Exponents-1"></a><a class="docs-heading-anchor-permalink" href="#Lyapunov-Exponents" title="Permalink"></a></h1><p>Lyapunov exponents measure exponential rates of separation of nearby trajectories in the flow of a dynamical system. The <a href="https://en.wikipedia.org/wiki/Lyapunov_exponent">Wikipedia</a> and the <a href="http://www.scholarpedia.org/article/Lyapunov_exponent">Scholarpedia</a> entries have a lot of valuable information about the history and usage of these quantities.</p><div class="admonition is-info"><header class="admonition-header">Performance depends on the solver</header><div class="admonition-body"><p>Notice that the performance of functions that use <code>ContinuousDynamicalSystem</code>s depend crucially on the chosen solver. Please see the documentation page on <a href="../../advanced/#Choosing-a-solver">Choosing a solver</a> for an in-depth discussion.</p></div></div><h2 id="Concept-of-the-Lyapunov-exponent"><a class="docs-heading-anchor" href="#Concept-of-the-Lyapunov-exponent">Concept of the Lyapunov exponent</a><a id="Concept-of-the-Lyapunov-exponent-1"></a><a class="docs-heading-anchor-permalink" href="#Concept-of-the-Lyapunov-exponent" title="Permalink"></a></h2><p>Before providing the documentation of the offered functionality, it is good to demonstrate exactly <em>what</em> are the Lyapunov exponents.</p><p>For chaotic systems, nearby trajectories separate in time exponentially fast (while for stable systems they come close exponentially fast). This happens at least for small separations, and is demonstrated in the following sketch:</p><p><img src="../lyapunov.png" alt/>.</p><p>In this sketch <span>$\lambda$</span> is the maximum Lyapunov exponent (and in general a system has as many exponents as its dimensionality).</p><p>Let&#39;s demonstrate these concepts using a real system, the Henon map:</p><p class="math-container">\[\begin{aligned}
x_{n+1} &amp;= 1 - ax_n^2 + y_n \\
y_{n+1} &amp;= bx_n
\end{aligned}\]</p><p>Let&#39;s get a trajectory</p><pre><code class="language- hljs">using DynamicalSystems, PyPlot
henon = Systems.henon()
tr1 = trajectory(henon, 100)
summary(tr1)</code></pre><p>and create one more trajectory that starts very close to the first one</p><pre><code class="language- hljs">u2 = get_state(henon) + (1e-9 * ones(dimension(henon)))
tr2 = trajectory(henon, 100, u2)
summary(tr2)</code></pre><p>We now want to demonstrate how the distance between these two trajectories increases with time:</p><pre><code class="language- hljs">using LinearAlgebra: norm

fig = figure()

# Plot the x-coordinate of the two trajectories:
ax1 = subplot(2,1,1)
plot(tr1[:, 1], alpha = 0.5)
plot(tr2[:, 1], alpha = 0.5)
ylabel(&quot;x&quot;)

# Plot their distance in a semilog plot:
ax2 = subplot(2,1,2, sharex = ax1)
d = [norm(tr1[i] - tr2[i]) for i in 1:length(tr2)]
ylabel(&quot;d&quot;); xlabel(&quot;n&quot;); semilogy(d);
fig.tight_layout(pad=0.3); fig</code></pre><p>The <em>initial</em> slope of the <code>d</code> vs <code>n</code> plot (before the curve saturates) is approximately the maximum Lyapunov exponent!</p><h2 id="Lyapunov-Spectrum"><a class="docs-heading-anchor" href="#Lyapunov-Spectrum">Lyapunov Spectrum</a><a id="Lyapunov-Spectrum-1"></a><a class="docs-heading-anchor-permalink" href="#Lyapunov-Spectrum" title="Permalink"></a></h2><p>The function <code>lyapunovspectrum</code> calculates the entire spectrum of the Lyapunov exponents of a system:</p><article class="docstring"><header><a class="docstring-binding" id="ChaosTools.lyapunovspectrum" href="#ChaosTools.lyapunovspectrum"><code>ChaosTools.lyapunovspectrum</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">lyapunovspectrum(ds::DynamicalSystem, N [, k::Int | Q0]; kwargs...) -&gt; λs</code></pre><p>Calculate the spectrum of Lyapunov exponents <sup class="footnote-reference"><a id="citeref-Lyapunov1992" href="#footnote-Lyapunov1992">[Lyapunov1992]</a></sup> of <code>ds</code> by applying a QR-decomposition on the parallelepiped matrix <code>N</code> times. Return the spectrum sorted from maximum to minimum.</p><p>The third argument <code>k</code> is optional, and dictates how many lyapunov exponents to calculate (defaults to <code>dimension(ds)</code>). Instead of passing an integer <code>k</code> you can pass a pre-initialized matrix <code>Q0</code> whose columns are initial deviation vectors (then <code>k = size(Q0)[2]</code>).</p><p>See also <a href="#ChaosTools.lyapunov"><code>lyapunov</code></a>, <a href="#ChaosTools.local_growth_rates"><code>local_growth_rates</code></a>.</p><p><strong>Keyword Arguments</strong></p><ul><li><code>u0 = get_state(ds)</code> : State to start from.</li><li><code>Ttr = 0</code> : Extra &quot;transient&quot; time to evolve the system before application of the algorithm. Should be <code>Int</code> for discrete systems. Both the system and the deviation vectors are evolved for this time.</li><li><code>Δt = 1</code> : Time of individual evolutions between successive orthonormalization steps. For continuous systems this is approximate.</li><li><code>show_progress = false</code> : Display a progress bar of the process.</li><li><code>diffeq...</code> : Keyword arguments propagated into <code>init</code> of DifferentialEquations.jl. See <a href="../../ds/general/#DynamicalSystemsBase.trajectory"><code>trajectory</code></a> for examples. Only valid for continuous systems.</li></ul><p><strong>Description</strong></p><p>The method we employ is &quot;H2&quot; of <sup class="footnote-reference"><a id="citeref-Geist1990" href="#footnote-Geist1990">[Geist1990]</a></sup>, originally stated in <sup class="footnote-reference"><a id="citeref-Benettin1980" href="#footnote-Benettin1980">[Benettin1980]</a></sup>. The deviation vectors defining a <code>D</code>-dimensional parallepiped in tangent space are evolved using the tangent dynamics of the system. A QR-decomposition at each step yields the local growth rate for each dimension of the parallepiped. The growth rates are then averaged over <code>N</code> successive steps, yielding the lyapunov exponent spectrum (at each step the parallepiped is re-normalized).</p><p><strong>Performance Notes</strong></p><p>This function uses a <a href="../../advanced/#DynamicalSystemsBase.tangent_integrator"><code>tangent_integrator</code></a>. For loops over initial conditions and/or parameter values one should use the low level method that accepts an integrator, and <code>reinit!</code> it to new initial conditions. See the &quot;advanced documentation&quot; for info on the integrator object. The low level method is</p><pre><code class="language-julia hljs">lyapunovspectrum(tinteg, N, Δt::Real, Ttr::Real)</code></pre><p>If you want to obtain the convergence timeseries of the Lyapunov spectrum, use the method</p><pre><code class="language-julia hljs">ChaosTools.lyapunovspectrum_convergence(tinteg, N, Δt, Ttr)</code></pre><p>(not exported).</p></div></section></article><hr/><p>As you can see, the documentation string is detailed and self-contained. For example, the Lyapunov spectrum of the <a href="http://www.scholarpedia.org/article/Hyperchaos">folded towel map</a> is calculated as:</p><pre><code class="language-julia hljs">using DynamicalSystems

ds = Systems.towel()
λλ = lyapunovspectrum(ds, 10000)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">3-element Vector{Float64}:
  0.43255716852280923
  0.3719692256789335
 -3.2969952533501163</code></pre><p>Similarly, for a continuous system, e.g. the Lorenz system, you would do:</p><pre><code class="language-julia hljs">lor = Systems.lorenz(ρ = 32.0) #this is not the original parameter!
λλ = lyapunovspectrum(lor, 10000, Δt = 0.1)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">3-element Vector{Float64}:
   0.9832918386627196
  -0.0010302911398397886
 -14.648908924106992</code></pre><p><code>lyapunovspectrum</code> is also very fast:</p><pre><code class="language-julia hljs">using BenchmarkTools
ds = Systems.towel()
@btime lyapunovspectrum($ds, 2000);</code></pre><pre><code class="nohighlight hljs">  237.226 μs (45 allocations: 4.27 KiB)</code></pre><p>Here is an example of plotting the exponents of the Henon map for various parameters:</p><pre><code class="language- hljs">using DynamicalSystems, PyPlot

he = Systems.henon()
as = 0.8:0.005:1.225; λs = zeros(length(as), 2)
for (i, a) in enumerate(as)
    set_parameter!(he, 1, a)
    λs[i, :] .= lyapunovspectrum(he, 10000; Ttr = 500)
end

fig = figure()
plot(as, λs); xlabel(&quot;\$a\$&quot;); ylabel(&quot;\$\\lambda\$&quot;)
fig.tight_layout(pad=0.3); fig</code></pre><h2 id="Maximum-Lyapunov-Exponent"><a class="docs-heading-anchor" href="#Maximum-Lyapunov-Exponent">Maximum Lyapunov Exponent</a><a id="Maximum-Lyapunov-Exponent-1"></a><a class="docs-heading-anchor-permalink" href="#Maximum-Lyapunov-Exponent" title="Permalink"></a></h2><p>It is possible to get only the maximum Lyapunov exponent simply by giving <code>1</code> as the third argument of <a href="#ChaosTools.lyapunovspectrum"><code>lyapunovspectrum</code></a>. However, there is a second algorithm that allows you to do the same thing, which is offered by the function <code>lyapunov</code>:</p><article class="docstring"><header><a class="docstring-binding" id="ChaosTools.lyapunov" href="#ChaosTools.lyapunov"><code>ChaosTools.lyapunov</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">lyapunov(ds::DynamicalSystem, Τ; kwargs...) -&gt; λ</code></pre><p>Calculate the maximum Lyapunov exponent <code>λ</code> using a method due to Benettin <sup class="footnote-reference"><a id="citeref-Benettin1976" href="#footnote-Benettin1976">[Benettin1976]</a></sup>, which simply evolves two neighboring trajectories (one called &quot;given&quot; and one called &quot;test&quot;) while constantly rescaling the test one. <code>T</code>  denotes the total time of evolution (should be <code>Int</code> for discrete systems).</p><p>See also <a href="#ChaosTools.lyapunovspectrum"><code>lyapunovspectrum</code></a>, <a href="#ChaosTools.local_growth_rates"><code>local_growth_rates</code></a>.</p><p><strong>Keyword Arguments</strong></p><ul><li><code>u0 = get_state(ds)</code> : Initial condition.</li><li><code>Ttr = 0</code> : Extra &quot;transient&quot; time to evolve the trajectories before starting to measure the expontent. Should be <code>Int</code> for discrete systems.</li><li><code>d0 = 1e-9</code> : Initial &amp; rescaling distance between the two neighboring trajectories.</li><li><code>upper_threshold = 1e-6</code> : Upper distance threshold for rescaling.</li><li><code>lower_threshold = 1e-12</code> : Lower distance threshold for rescaling (in order to  be able to detect negative exponents).</li><li><code>Δt = 1</code> : Time of evolution between each check of distance exceeding the thresholds. For continuous systems this is approximate.</li><li><code>inittest = (u1, d0) -&gt; u1 .+ d0/sqrt(D)</code> : A function that given <code>(u1, d0)</code> initializes the test state with distance <code>d0</code> from the given state <code>u1</code> (<code>D</code> is the dimension of the system). This function can be used when you want to avoid the test state appearing in a region of the phase-space where it would have e.g. different energy or escape to infinity.</li><li><code>diffeq...</code> : Keyword arguments propagated into <code>init</code> of DifferentialEquations.jl. See <a href="../../ds/general/#DynamicalSystemsBase.trajectory"><code>trajectory</code></a> for examples. Only valid for continuous systems.</li></ul><p><strong>Description</strong></p><p>Two neighboring trajectories with initial distance <code>d0</code> are evolved in time. At time <span>$t_i$</span> their distance <span>$d(t_i)$</span> either exceeds the <code>upper_threshold</code>, or is lower than <code>lower_threshold</code>, which initializes a rescaling of the test trajectory back to having distance <code>d0</code> from the given one, while the rescaling keeps the difference vector along the maximal expansion/contraction direction: <span>$u_2 \to u_1+(u_2−u_1)/(d(t_i)/d_0)$</span>.</p><p>The maximum Lyapunov exponent is the average of the time-local Lyapunov exponents</p><p class="math-container">\[\lambda = \frac{1}{t_{n} - t_0}\sum_{i=1}^{n}
\ln\left( a_i \right),\quad a_i = \frac{d(t_{i})}{d_0}.\]</p><p><strong>Performance Notes</strong></p><p>This function uses a <a href="../../advanced/#DynamicalSystemsBase.parallel_integrator"><code>parallel_integrator</code></a>. For loops over initial conditions and/or parameter values one should use the low level method that accepts an integrator, and <code>reinit!</code> it to new initial conditions. See the &quot;advanced documentation&quot; for info on the integrator object. The low level method is</p><pre><code class="nohighlight hljs">lyapunov(pinteg, T, Ttr, Δt, d0, ut, lt)</code></pre></div></section></article><hr/><p>For example:</p><pre><code class="language- hljs">using DynamicalSystems, PyPlot
henon = Systems.henon()
λ = lyapunov(henon, 10000, d0 = 1e-7, upper_threshold = 1e-4, Ttr = 100)</code></pre><p>The same is done for continuous systems:</p><pre><code class="language-julia hljs">lor = Systems.lorenz(ρ = 32)
λ = lyapunov(lor, 10000.0, Δt = 10.0, Ttr = 100.0)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">0.9940611981557061</code></pre><h2 id="Local-Growth-Rates"><a class="docs-heading-anchor" href="#Local-Growth-Rates">Local Growth Rates</a><a id="Local-Growth-Rates-1"></a><a class="docs-heading-anchor-permalink" href="#Local-Growth-Rates" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="ChaosTools.local_growth_rates" href="#ChaosTools.local_growth_rates"><code>ChaosTools.local_growth_rates</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">local_growth_rates(ds, points::Dataset; S=100, Δt=5, kwargs...) → λlocal</code></pre><p>Compute the exponential local growth rate(s) of perturbations of the dynamical system <code>ds</code> for initial conditions given in <code>points</code>. For each initial condition <code>u ∈ points</code>, <code>S</code> total perturbations are created and evolved for time <code>Δt</code>. The exponential local growth rate is defined simply by <code>log(g/g0)/Δt</code> with <code>g0</code> the initial pertrubation size and <code>g</code> the size after <code>Δt</code>. Thus, <code>λlocal</code> is a matrix of size <code>(length(points), S)</code>.</p><p>This function is a modification of <a href="#ChaosTools.lyapunov"><code>lyapunov</code></a>. It uses the full nonlinear dynamics to evolve the perturbations, but does not do any re-scaling, thus allowing probing state and time dependence of perturbation growth. The actual growth is given by <code>exp(λlocal * Δt)</code>.</p><p>The output of this function is sometimes referred as &quot;Nonlinear Local Lyapunov Exponent&quot;.</p><p><strong>Keyword Arguments</strong></p><ul><li><code>perturbation</code>: If given, it should be a function <code>perturbation(ds, u, j)</code> that outputs a pertrubation vector (preferrably <code>SVector</code>) given the system, current initial condition <code>u</code> and the counter <code>j ∈ 1:S</code>. If not given, a random perturbation is generated with norm given by the keyword <code>e = 1e-6</code>.</li><li><code>diffeq...</code>: Keywords propagated to the solvers of DifferentialEquations.jl.</li></ul></div></section></article><p>Here is a simple example using the Henon map</p><pre><code class="language- hljs">using Statistics

ds = Systems.henon()
points = trajectory(ds, 2000; Ttr = 100)

λlocal = local_growth_rates(ds, points; Δt = 1)

λmeans = mean(λlocal; dims = 2)
λstds = std(λlocal; dims = 2)
fig = figure()
x, y = columns(points)
scatter(x, y; c=vec(λmeans), alpha = 0.5)
colorbar()
fig.tight_layout(pad=0.3); fig</code></pre><h2 id="Lyapunov-exponent-from-data"><a class="docs-heading-anchor" href="#Lyapunov-exponent-from-data">Lyapunov exponent from data</a><a id="Lyapunov-exponent-from-data-1"></a><a class="docs-heading-anchor-permalink" href="#Lyapunov-exponent-from-data" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="ChaosTools.lyapunov_from_data" href="#ChaosTools.lyapunov_from_data"><code>ChaosTools.lyapunov_from_data</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">lyapunov_from_data(R::Dataset, ks;  refstates, w, distance, ntype)</code></pre><p>Return <code>E = [E(k) for k ∈ ks]</code>, where <code>E(k)</code> is the average logarithmic distance between states of a neighborhood that are evolved in time for <code>k</code> steps (<code>k</code> must be integer). The slope of <code>E</code> vs <code>k</code> approximate the maximum Lyapunov exponent, see below. Typically <code>R</code> is the result of delay coordinates of a single timeseries.</p><p><strong>Keyword Arguments</strong></p><ul><li><code>refstates = 1:(length(R) - ks[end])</code> : Vector of indices that notes which states of the reconstruction should be used as &quot;reference states&quot;, which means that the algorithm is applied for all state indices contained in <code>refstates</code>.</li><li><code>w::Int = 1</code> : The <a href="../../embedding/dataset/#Theiler-window">Theiler window</a>.</li><li><code>ntype = NeighborNumber(1)</code> : The neighborhood type. Either <a href="../../embedding/dataset/#Neighborhood.NeighborNumber"><code>NeighborNumber</code></a> or <a href="../../embedding/dataset/#Neighborhood.WithinRange"><code>WithinRange</code></a>. See <a href="../../embedding/dataset/#Neighborhoods">Neighborhoods</a> for more info.</li><li><code>distance::Metric = Cityblock()</code> : The distance function used in the logarithmic distance of nearby states. The allowed distances are <code>Cityblock()</code> and <code>Euclidean()</code>. See below for more info. The metric for finding neighbors is always the Euclidean one.</li></ul><p><strong>Description</strong></p><p>If the dataset exhibits exponential divergence of nearby states, then it should hold</p><p class="math-container">\[E(k) \approx \lambda\cdot k \cdot \Delta t + E(0)\]</p><p>for a <em>well defined region</em> in the <code>k</code> axis, where <span>$\lambda$</span> is the approximated maximum Lyapunov exponent. <span>$\Delta t$</span> is the time between samples in the original timeseries. You can use <a href="../fractaldim/#ChaosTools.linear_region"><code>linear_region</code></a> with arguments <code>(ks .* Δt, E)</code> to identify the slope (= <span>$\lambda$</span>) immediatelly, assuming you have choosen sufficiently good <code>ks</code> such that the linear scaling region is bigger than the saturated region.</p><p>The algorithm used in this function is due to Parlitz<sup class="footnote-reference"><a id="citeref-Skokos2016" href="#footnote-Skokos2016">[Skokos2016]</a></sup>, which itself expands upon Kantz <sup class="footnote-reference"><a id="citeref-Kantz1994" href="#footnote-Kantz1994">[Kantz1994]</a></sup>. In sort, for each reference state a neighborhood is evaluated. Then, for each point in this neighborhood, the logarithmic distance between reference state and neighborhood state(s) is calculated as the &quot;time&quot; index <code>k</code> increases. The average of the above over all neighborhood states over all reference states is the returned result.</p><p>If the <code>Metric</code> is <code>Euclidean()</code> then use the Euclidean distance of the full <code>D</code>-dimensional points (distance <span>$d_E$</span> in ref.<sup class="footnote-reference"><a id="citeref-Skokos2016" href="#footnote-Skokos2016">[Skokos2016]</a></sup>). If however the <code>Metric</code> is <code>Cityblock()</code>, calculate the absolute distance of <em>only the first elements</em> of the <code>m+k</code> and <code>n+k</code> points of <code>R</code> (distance <span>$d_F$</span> in ref.<sup class="footnote-reference"><a id="citeref-Skokos2016" href="#footnote-Skokos2016">[Skokos2016]</a></sup>, useful when <code>R</code> comes from delay embedding).</p></div></section></article><h3 id="Example"><a class="docs-heading-anchor" href="#Example">Example</a><a id="Example-1"></a><a class="docs-heading-anchor-permalink" href="#Example" title="Permalink"></a></h3><pre><code class="language- hljs">using DynamicalSystems, PyPlot

ds = Systems.henon()
data = trajectory(ds, 100000)
x = data[:, 1] #fake measurements for the win!

ks = 1:20
ℜ = 1:10000
fig = figure(figsize=(10,6))

for (i, di) in enumerate([Euclidean(), Cityblock()])
    subplot(1, 2, i)
    ntype = NeighborNumber(2)
    title(&quot;Distance: $(di)&quot;, size = 18)
    for D in [2, 4, 7]
        R = embed(x, D, 1)
        E = lyapunov_from_data(R, ks;
        refstates = ℜ, distance = di, ntype = ntype)
        Δt = 1
        λ = linear_region(ks.*Δt, E)[2]
        # gives the linear slope, i.e. the Lyapunov exponent
        plot(ks .- 1, E .- E[1], label = &quot;D=$D, λ=$(round(λ, digits = 3))&quot;)
        legend()
        tight_layout()
    end
end
tight_layout(pad=0.3); fig</code></pre><h3 id="Bad-Time-axis-(ks)-length"><a class="docs-heading-anchor" href="#Bad-Time-axis-(ks)-length">Bad Time-axis (<code>ks</code>) length</a><a id="Bad-Time-axis-(ks)-length-1"></a><a class="docs-heading-anchor-permalink" href="#Bad-Time-axis-(ks)-length" title="Permalink"></a></h3><div class="admonition is-danger"><header class="admonition-header">Large `ks`</header><div class="admonition-body"><p>This simply cannot be stressed enough! It is just too easy to overshoot the range at which the exponential expansion region is valid!</p></div></div><p>Let&#39;s revisit the example of the previous section:</p><pre><code class="language-julia hljs">ds = Systems.henon()
data = trajectory(ds, 100000)
x = data[:, 1]
length(x)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">100001</code></pre><p>The timeseries of such length could be considered big. A time length of 100 seems very small. Yet it turns out it is way too big! The following</p><pre><code class="language- hljs">ks = 1:100
R = embed(x, 2, 1)
E = lyapunov_from_data(R, ks, ntype = NeighborNumber(2))
fig = figure()
plot(ks .- 1, E .- E[1])
title(&quot;Lyapunov: $(linear_region(ks, E)[2])&quot;)
fig.tight_layout(pad=0.3); fig</code></pre><p>Notice that even though this value for the Lyapunov exponent is correct, it happened to be correct simply due to the jitter of the saturated region. Since the saturated region is much bigger than the linear scaling region, if it wasn&#39;t that jittery the function <a href="../fractaldim/#ChaosTools.linear_region"><code>linear_region</code></a> would not give the scaling of the linear region, but instead a slope near 0! (or if you were to give bigger tolerance as a keyword argument)</p><h3 id="Case-of-a-Continuous-system"><a class="docs-heading-anchor" href="#Case-of-a-Continuous-system">Case of a Continuous system</a><a id="Case-of-a-Continuous-system-1"></a><a class="docs-heading-anchor-permalink" href="#Case-of-a-Continuous-system" title="Permalink"></a></h3><p>The process for continuous systems works identically with discrete, but one must be a bit more thoughtful when choosing parameters. The following example helps the users get familiar with the process:</p><pre><code class="language- hljs">using DynamicalSystems, PyPlot

ds = Systems.lorenz()
# create a timeseries of 1 dimension
Δt = 0.05
x = trajectory(ds, 1000.0; Δt)[:, 1]</code></pre><p>We know that we have to use much bigger <code>ks</code> than <code>1:20</code>, because this is a continuous case! (See reference given in <code>lyapunov_from_dataspectrum</code>)</p><pre><code class="language-julia hljs">ks1 = 0:200</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">0:200</code></pre><p>and in fact it is even better to not increment the <code>ks</code> one by one but instead do</p><pre><code class="language-julia hljs">ks2 = 0:4:200</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">0:4:200</code></pre><p>Now we plot some example computations</p><pre><code class="language- hljs">fig = figure()
ntype = NeighborNumber(5) #5 nearest neighbors of each state

for d in [4, 8], τ in [7, 15]
    r = embed(x, d, τ)

    # E1 = lyapunov_from_data(r, ks1; ntype)
    # λ1 = linear_region(ks1 .* Δt, E1)[2]
    # plot(ks1,E1.-E1[1], label = &quot;dense, d=$(d), τ=$(τ), λ=$(round(λ1, 3))&quot;)

    E2 = lyapunov_from_data(r, ks2; ntype)
    λ2 = linear_region(ks2 .* Δt, E2)[2]
    plot(ks2,E2.-E2[1], label = &quot;d=$(d), τ=$(τ), λ=$(round(λ2, digits = 3))&quot;)
end

legend()
xlabel(&quot;k (0.05×t)&quot;)
ylabel(&quot;E - E(0)&quot;)
title(&quot;Continuous Reconstruction Lyapunov&quot;)
fig.tight_layout(pad=0.3); fig</code></pre><p>As you can see, using <code>τ = 15</code> is not a great choice! The estimates with <code>τ = 7</code> though are very good (the actual value is around <code>λ ≈ 0.89...</code>).</p><section class="footnotes is-size-7"><ul><li class="footnote" id="footnote-Lyapunov1992"><a class="tag is-link" href="#citeref-Lyapunov1992">Lyapunov1992</a>A. M. Lyapunov, <em>The General Problem of the Stability of Motion</em>, Taylor &amp; Francis (1992)</li><li class="footnote" id="footnote-Geist1990"><a class="tag is-link" href="#citeref-Geist1990">Geist1990</a>K. Geist <em>et al.</em>, Progr. Theor. Phys. <strong>83</strong>, pp 875 (1990)</li><li class="footnote" id="footnote-Benettin1980"><a class="tag is-link" href="#citeref-Benettin1980">Benettin1980</a>G. Benettin <em>et al.</em>, Meccanica <strong>15</strong>, pp 9-20 &amp; 21-30 (1980)</li><li class="footnote" id="footnote-Benettin1976"><a class="tag is-link" href="#citeref-Benettin1976">Benettin1976</a>G. Benettin <em>et al.</em>, Phys. Rev. A <strong>14</strong>, pp 2338 (1976)</li><li class="footnote" id="footnote-Skokos2016"><a class="tag is-link" href="#citeref-Skokos2016">Skokos2016</a>Skokos, C. H. <em>et al.</em>, <em>Chaos Detection and Predictability</em> - Chapter 1 (section 1.3.2), Lecture Notes in Physics <strong>915</strong>, Springer (2016)</li><li class="footnote" id="footnote-Kantz1994"><a class="tag is-link" href="#citeref-Kantz1994">Kantz1994</a>Kantz, H., Phys. Lett. A <strong>185</strong>, pp 77–87 (1994)</li></ul></section></article><nav class="docs-footer"><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.10 on <span class="colophon-date" title="Saturday 4 December 2021 20:51">Saturday 4 December 2021</span>. Using Julia version 1.7.0.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
